---
title: 'Dynamic Programming - Memoization'

date: '2024-06-08'

lastmod: '2024-06-10'

tags: ['算法', '动态规划', '性能优化']

draft: false

summary: '深入解析top-down形式的dynamic programming(dp)，也就是memoization。我们会解决一道道的经典题目，例如斐波那契数列，gridTraveler，canSum, howSum, bestSum等等，彻底理解和掌握memoization。'
---

## Introduction

在学习掘金[前端算法与数据结构面试](https://juejin.cn/book/6844733800300150797?enter_from=course_center&utm_source=course_center)这本小册的时候，啃到动态规划部分有点啃不动。在youtube找了一个[很好的视频](https://www.youtube.com/watch?v=oBt53YbR9Kk&list=PLtc4S9-a2fprxWMv_ZR0ggxJOdXAT_Gd5&index=22)专门讲动态规划，这个系列将会记录我学习动态规划的笔记与心得。视频把动态规划解法分为了memoization和tabulation两种形式，这篇文章主要讲memoization。

<TOCInline toc={props.toc} exclude="Introduction" />

## 斐波那契数列

要打开动态规划（Dynamic Programming）的大门，我们首先来看一下斐波那契数列，根据维基百科上的定义，斐波那契数列由0和1开始，之后的斐波那契数由之前的两数相加得出，由此可知斐波那契数列是：

```
1、1、2、3、5、8、13、21、24、55、89、144、233...
```

在数学上，斐波那契数以递归的方法来定义：

```
F(0)=0
F(1)=1
F(n) =F(n-1)+F(n-1)
```

leetcode第509题就以此为题干：

> The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,
>
> ```
> F(0) = 0, F(1) = 1
> F(n) = F(n - 1) + F(n - 2), for n > 1.
>
> ```
>
> Given n, calculate F(n).

### 递归解法

我们试着用递归的方式来解这道题：

```javascript
const fib = (n) => {
  if (n <= 2) return 1
  return fib(n - 1) + fib(n - 2)
}
```

打印`fib(5)`, `fib(6)`, `fib(7)`, 都没问题，分别输出5、8、13，但是一旦打印较大的数字例如`fib(50)`就会变得很慢，在性能上有大问题。提前告诉大家，它的时间复杂度是`O(2^n)`。

<Image alt="treeVisual" src="/static/images/blog-06-2024/treeVisual.png" width={500} height={300} />

### 复杂度分析

在解释为什么上面那种解法时间复杂度大之前，我们先来看几组例子分析一下时间空间复杂度，算是热热身，真正搞懂递归的时间空间复杂度怎么算。

**例1**

```javascript
const foo = (n) => {
  if (n <= 1) return
  foo(n - 1)
}
```

对于`foo(5)`来说，函数跑了`5`次。那么对于`f(n)`来说就会跑`n`次。所以时间复杂度是`O(n)`。

那么空间复杂度呢？对于每次调用，函数执行上下文都会被推入调用栈，所以空间复杂度也是`O(n)`。

**例2**

```javascript
const foo = (n) => {
  if (n <= 1) return
  foo(n - 1)
}
```

对于`foo(6)`跑了4次，对于`foo(7)`会跑5次，对于`foo(8)`会跑5次，对于`foo(9)` 会跑6次......总结一下规律就是`Math.ceil(n/2) + 1`, 时间复杂度是大约是`O (n/2)`，根据Big O Notation，我们在计算时间复杂度的时候，可以把常数项忽略，所以这个函数的时间复杂度大约也是`O(n)`。此时时间复杂度也是`O(n)`。

**例3**

```javascript
const dib = (n) => {
  if (n <= 1) return
  dib(n - 1)
  dib(n - 1)
}
```

画图：

<Image
  alt="treeVisual2"
  src="/static/images/blog-06-2024/treeVisual2.png"
  width={500}
  height={300}
/>

可以看到树的高度是n，对于第一层来说`2^0`个节点，对于第二层有`2^1`个节点，第三层`2^2`，第n层`2^n`，一个节点意味着函数被调用一次。所以在这个算法中，时间复杂度为`O(2^n)`。

但这次空间复杂度不是`O(2^n)`，我们主要看调用栈里的函数最多的时候有多少个，它和输入n的关系是什么。

当我们递归第一行`dib(n-1)`的时候，它会一直行进到`dib(1-1)`，也就是叶子节点那里。此时调用栈中大约有n个函数，再继续就要把dib(0)出栈，然后走下一行的`dib(n-1)`，如上图所画的绿色路线。所以这个算法的空间复杂度最大是`O(n)`。

**例4**

```javascript
const lib = (n) => {
  if (n <= 1) return
  lib(n - 2)
  lib(n - 2)
}
```

对于这个例子，它和上面唯一的区别就是，n-1变成了n-2。

相应的，时间复杂度是O(2^(n/2))，空间复杂度是O(n/2)，简化一下和上个例子的时间空间复杂度还是一样的。

最后看回我们斐波那契数列算法：

```javascript
const fib = (n) => {
  if (n <= 2) return 1
  return fib(n - 1) + fib(n - 2)
}
```

它的时间复杂度应该介于dib和lib之间，而dib和lib都是`2^n`，可以推想fib的时间复杂度也是`2^n`。

对于`fib(7)`，函数调用最满的时候，时间复杂度也是`2^n`。空间复杂度大约是`O(n)`，调用栈里最多有n个函数。

在计算fib(50)的时候，函数跑了很多次，如下：

<Image alt="duplicated" src="/static/images/blog-06-2024/duplicated.png" width={500} height={300} />

当我们以`fib(7)`为例画出递归树图之后会发现，很多节点的值被重复计算了，浪费了大量计算资源。

### Memoization解法

如果我们能记住已经计算过的结果，就能大大提高算法速度。我们往fib函数加上第二个参数memo，如下：

```javascript
const fib = (n, memo = {}) => {
  if (n in memo) return memo[n]
  if (n <= 2) return 1
  memo[n] = fib(n - 1, memo) + fib(n - 2, memo)
  return memo[n]
}
```

如果在memo里能找到这个`n`，就返回`memo[n]`，如果找不到，就把这次返回的结果记录到`memo[n]`里。
这样我们就避免了重复计算。

我们来计算一下这个解法的时间和空间复杂度，以`fib(6)`为例：

<Image alt="treeVisual" src="/static/images/blog-06-2024/memoized.png" width={500} height={300} />

再看`fib(7)``fib(8)``fib(9)`，我们会发现函数被调用的次数实际上就是`2n`，被推入栈的函数数量也是`2n`，所以这个解法的时间和空间复杂度都是`O(n)`。

<Image
  alt="treeVisual"
  src="/static/images/blog-06-2024/fib-memoized.png"
  width={500}
  height={300}
/>

## gridTraveler

### 问题描述

gridTraveler是一个经典的动态规划问题，题目是这样的：

There is a robot on an `m x n` grid. The robot is initially located at the top-left corner (i.e., `grid[0][0]`).
The robot tries to move to the bottom-right corner (i.e., `grid[m - 1][n - 1]`).
The robot can only move either down or right at any point in time.
Given the two integers `m` and `n`, return the number of possible unique paths that the robot can take to reach the bottom-right corner.
The test cases are generated so that the answer will be less than or equal to `2 * 109`.

<Image
  alt="treeVisual"
  src="/static/images/blog-06-2024/grid-traveler1.png"
  width={300}
  height={300}
/>

我们可以想象有一个绿色的小人站在左上角，他唯一能做的选择是往下或者往右走，直到走到右下角。我们可以用递归的方式来解这道题：

如果他如上图向下走了一步，这个问题就可以变成是`3*2`格子的问题，如果他向右走了一步，这个问题就可以变成是`2*3`格子的问题。他可以走到右下角的所有方式等于向下走的方式加上向右走的方式。

随着他一直走，最终会走到边缘情况例如`1*1`的格子，这个时候就只有一种走法。如果是`0*1`或者`1*0`的格子，就是没有走法。

### 递归解法

根据以上的描述，我们可以写一个最简单的写法：

```javascript
function gridTraveler(m, n) {
  if (m == 1 && n == 1) return 1
  if (m == 0 || n == 0) return 0
  return gridTraveler(m - 1, n) + gridTraveler(m, n - 1)
}
```

这种解法确实能够解决问题，但是对于较大的网格，计算就会很慢，我们可以看看下面这张树状图：

<Image
  alt="treeVisual"
  src="/static/images/blog-06-2024/grid-traveler2.png"
  width={500}
  height={300}
/>

图中`gridTraveler(1,2)`、`gridTraveler(2,1)`、`gridTraveler(1,1)`等都被重复计算了，我们可以用memoization来优化这个问题。

### Memoization解法

```javascript
function gridTraveler(m, n, memo = {}) {
  const key = m + ',' + n
  if (key in memo) return memo[key]
  if (m == 1 && n == 1) return 1
  if (m == 0 || n == 0) return 0
  memo[key] = gridTraveler(m - 1, n, memo) + gridTraveler(m, n - 1, memo)
  return memo[key]
}
```

往`gridTraveler` 里加上第三个参数 `memo`，这样我们就能记住已经计算过的结果，避免重复计算。key使用`m + ',' + n`来表示，这样就能唯一标识一个路线。

### 复杂度分析

对于时间复杂度来说，是`O(m*n)`，因为我们最多会调用`m*n`次函数。对于空间复杂度来说，是`O(m+n)`，因为我们最多会推入`m+n`个函数。
